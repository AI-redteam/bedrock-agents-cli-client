# ptchat.py
import typer
import questionary
from rich.console import Console
from rich.markdown import Markdown
from rich.table import Table
from datetime import datetime, timezone

# Import our custom modules from the 'ptchat' package
from ptchat import config, session_manager, bedrock_client

# Initialize Typer app and Rich console
app = typer.Typer(name="ptchat", help="A CLI chatbot for your Bedrock Knowledge Base.")
session_app = typer.Typer(help="Manage chat sessions.")
app.add_typer(session_app, name="session")

console = Console()

@session_app.command("list")
def list_all_sessions():
    """Lists all saved chat sessions."""
    sessions = session_manager.list_sessions()
    if not sessions:
        console.print("No saved sessions found.")
        return

    table = Table("Session Name", "Last Updated")
    for session in sessions:
        last_updated_str = datetime.fromisoformat(session['lastUpdatedAt']).strftime('%Y-%m-%d %r')
        table.add_row(session['sessionName'], last_updated_str)
    console.print(table)


@session_app.command("delete")
def delete_a_session():
    """Deletes a saved chat session."""
    sessions = session_manager.list_sessions()
    if not sessions:
        console.print("No sessions to delete.")
        return
        
    session_name_to_delete = questionary.select(
        "Which session would you like to delete?",
        choices=[s['sessionName'] for s in sessions]
    ).ask()

    if session_name_to_delete:
        if questionary.confirm(f"Are you sure you want to delete '{session_name_to_delete}'?").ask():
            if session_manager.delete_session(session_name_to_delete):
                console.print(f"[green]Session '{session_name_to_delete}' deleted.[/green]")
            else:
                console.print(f"[red]Error deleting session.[/red]")

@app.command("start")
def start_chat():
    """Starts a new chat session or resumes an existing one."""
    app_config = config.load_config()
    session_data = {}

    # --- Session Selection Menu ---
    sessions = session_manager.list_sessions()
    choices = ["[New Session]"] + [s['sessionName'] for s in sessions]
    
    choice = questionary.select(
        "Select a session to continue, or start a new one:",
        choices=choices
    ).ask()

    if not choice: # User cancelled
        return

    if choice == "[New Session]":
        session_data = {
            "sessionName": None, # Will be set on first save
            "sessionId": None,
            "createdAt": datetime.now(timezone.utc).isoformat(),
            "chatHistory": []
        }
        console.print("[bold cyan]Started a new chat session. Type /help for commands.[/bold cyan]")
    else:
        session_data = session_manager.load_session(choice)
        console.print(f"[bold cyan]Resumed session: {choice}[/bold cyan]")
        console.rule()
        # Reprint history
        for entry in session_data.get("chatHistory", []):
            if entry['role'] == 'user':
                console.print(f"[bold green]You:[/bold green] {entry['content']}")
            else:
                console.print(f"[bold blue]AI:[/bold blue]")
                console.print(Markdown(entry['content']))
            console.print("")
        console.rule()

    # --- Main Chat Loop ---
    while True:
        try:
            prompt = questionary.text("You:").ask()
            if prompt is None: # User pressed Ctrl+C
                break
            
            prompt = prompt.strip()
            if not prompt:
                continue

            # --- Meta Commands ---
            if prompt.lower() in ["/quit", "/exit"]:
                break
            elif prompt.lower() == "/help":
                console.print("Commands: /save <name>, /rename <new-name>, /quit, /exit, /help")
                continue
            elif prompt.lower().startswith("/save"):
                new_name = prompt[5:].strip()
                if not new_name and not session_data.get("sessionName"):
                    new_name = questionary.text("Enter a name for this session:").ask()
                    if not new_name:
                        console.print("[yellow]Save cancelled.[/yellow]")
                        continue
                
                if new_name:
                    session_data["sessionName"] = new_name
                
                session_manager.save_session(session_data)
                console.print(f"[green]Session saved as '{session_data['sessionName']}'.[/green]")
                continue

            # --- API Call ---
            with console.status("[bold yellow]AI is thinking...[/bold yellow]", spinner="dots"):
                response = bedrock_client.retrieve_and_generate(
                    app_config, 
                    prompt, 
                    session_data.get("sessionId")
                )

            if "error" in response:
                console.print(f"[bold red]Error: {response['error']}[/bold red]")
                continue

            # --- Process and Display Response ---
            ai_response_text = response["output"]["text"]
            session_data["sessionId"] = response["sessionId"] # IMPORTANT: Update session ID
            
            session_data["chatHistory"].append({"role": "user", "content": prompt})
            session_data["chatHistory"].append({"role": "assistant", "content": ai_response_text})
            
            console.print(f"[bold blue]AI:[/bold blue]")
            console.print(Markdown(ai_response_text))
            
            # Auto-save after each turn if the session is named
            if session_data.get("sessionName"):
                session_manager.save_session(session_data)

        except KeyboardInterrupt:
            break
            
    console.print("\nGoodbye!")

if __name__ == "__main__":
    app()
